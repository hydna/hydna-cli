#!/usr/bin/env python
import errno
import httplib
import json
import optparse
import os
import socket
import sys
import time
import urllib
import urlparse
import uuid
import zipfile

from StringIO import StringIO

# API_HOST = "http://127.0.0.1:8000/"
API_HOST = "https://www.hydna.com/"

DEFAULT_UPLOAD_NAME = 'behavior.zip'
MAX_UPLOAD_SIZE = 2

# exceptions

class CommandNotFound(Exception):
    def __init__(self, command_name):
        self.command_name = command_name


class APIRequestError(Exception):
    def __init__(self, url, msg):
        self.url = url
        self.msg = msg


class APIAuthenticationError(Exception):
    def __init__(self):
        self.msg = u"Unable to authenticate."


# command framework

class Option(object):
    def __init__(self, dest, opt_str=None, opt_str_long=None, required=False):
        self.dest = dest
        self.opt_str = opt_str
        self.opt_str_long = opt_str_long
        self.required = required

        if opt_str is None and opt_str_long is None:
            raise ValueError("You must specify at least one of opt_str and "
                             "opt_str_long")


class Command(object):
    name = None
    options = []

    def __init__(self):
        usage = "usage: %%prog %s [opts]" % self.name

        self.parser = optparse.OptionParser(usage)
        self._required_options = []

        for option in self.options:
            self.add_option(option)
            if option.required:
                self._required_options.append(option.dest)

    def add_option(self, option):
        self.parser.add_option(option.opt_str, option.opt_str_long,
                               dest=option.dest)

    def validate(self, arguments):
        opts, _rest = self.parser.parse_args(arguments)
        for required_option in self._required_options:
            if getattr(opts, required_option) is None:
                self.parser.error("Missing one or more required options.")
        return opts

    def error(self, message):
        self.parser.error(message)

    def run(self, opts):
        raise NotImplementedError


def get_command(command_name):
    """Return `Command` subclass with a `Command.name` matching
    `command_name.

    """
    for command_cls in COMMANDS:
        if command_cls.name == command_name:
            return command_cls
    raise CommandNotFound(command_name)

def dispatch():
    """Validate arguments and dispatch subcommand. Or print usage string."""
    if len(sys.argv) > 1:
        command_name = sys.argv[1]
        arguments = sys.argv[1:]

        try:
            command_cls = get_command(command_name)
        except CommandNotFound, e:
            sys.stderr.write("Command not found: '%s'\n" % e.command_name)
            sys.exit(1)

        command = command_cls()
        opts = command.validate(arguments)

        try:
            command.run(opts)
        except KeyboardInterrupt, e:
            print
    else:
        parser = optparse.OptionParser("%prog <command> [opts]")
        sys.stderr.write("%s\n" % parser.get_usage())
        sys.stderr.write("\nAvailable commands:\n")
        for command in COMMANDS:
            sys.stderr.write("    %s\n" % command.name)
        sys.exit(1)

# commands

class PushBehaviorCommand(Command):
    """Upload behaviors in current directory to Hydna for validation and
    deployment.

    """
    name = 'push'
    options = [
        Option('api_key', '-a', '--api-key', required=True),
        Option('domain_name', '-d', '--domain', required=True),
    ]

    def run(self, opts):
        if not os.path.isfile('./setup.be'):
            self.error("No 'setup.be' in current working directory.")

        if not self.is_valid_api_key(opts.api_key):
            self.error("Invalid api key.")

        archive = self.archive(os.getcwd())

        if archive.tell() > MAX_UPLOAD_SIZE * 1024 * 1024:
            self.error("Behaviors may not be larger than %s MB "
                       "in size" % MAX_UPLOAD_SIZE)

        try:
            response = self.push_behavior(opts.domain_name, opts.api_key,
                                          archive)
        except APIRequestError, e:
            sys.stderr.write("[ERROR] %s\n" % e.msg)
            sys.exit(1)
        except APIAuthenticationError, e:
            sys.stderr.write("[ERROR] %s\n" % e.msg)
            sys.exit(1)

        if response['status']:
            if 'be_validation_error' in response:
                sys.stderr.write("[ERROR] Files did not pass "
                                 "validation:\n\n")
                sys.stderr.write("%s\n" % response['be_validation_error'])
                sys.exit(1)

            sys.stderr.write("[ERROR] Unexpected error.\n")
            sys.exit(1)

        print "[OK] Behaviors deployed."
            
    def is_valid_api_key(self, api_key):
        path = '/api/1/ping/'
        url = urlparse.urljoin(API_HOST, path)
        headers = { 'X-Api-Key': api_key }
        response = request(url, method='GET', headers=headers)
        if response.status == httplib.OK:
            return True
        return False

    def push_behavior(self, domain_name, api_key, archive):
        path = '/api/1/domains/%s/behaviors/' % domain_name
        url = urlparse.urljoin(API_HOST, path)

        files = { 'file': archive }
        headers = { 'X-Api-Key': api_key }

        def upload_callback():
            print "[OK] Upload done, deploying to domain ..."

        return api_request(url, 'POST', files=files, headers=headers,
                           accepted_callback=upload_callback)

    def archive(self, path):
        """Create a zip-archive of `path`."""
        buf = StringIO()
        buf.name = DEFAULT_UPLOAD_NAME

        zf = zipfile.ZipFile(buf, 'w')

        for root, dirnames, filenames in os.walk(path):
            if os.path.basename(root) and os.path.basename(root)[0] in '._':
                continue

            for filename in filenames:
                if filename[0] in '._':
                    continue

                full_path = os.path.join(root, filename)
                zf.write(full_path, full_path[len(path) + len(os.sep):])

        zf.close()
        return buf


COMMANDS = (PushBehaviorCommand, )

# http stuff

def http_connection_cls(for_https=False, for_file_transfer=False):
    """Generate and return a class that is tailored for the needs indicated by
    `for_https` and `for_file_transfer`.

    """
    base_cls = for_https and httplib.HTTPSConnection or httplib.HTTPConnection

    if not for_file_transfer:
        return base_cls

    class HTTPConnectionWithProgress(base_cls):
        CHUNK_SIZE = 2048

        def show_progress(self, bit, total, barlength=10):   
            d = bit / float(total)
            bars = int(d * barlength)
            percentage = int(100 * d)

            bar = '[%s]' % (bars * '#').ljust(barlength)
            sys.stdout.write("\r%s %s%% %s" % (bar, str(percentage).rjust(3),
                                               'uploaded'))
            sys.stdout.flush()

        def done(self, total_size):
            print ""

        def send(self, data):
            total_size = len(data)
            sent = 0

            if self.sock is None:
                self.connect()

            while sent < total_size:
                offset = sent + min(total_size - sent, self.CHUNK_SIZE)
                try:
                    self.sock.sendall(data[sent:offset])
                except socket.error, e:
                    if e[0] == errno.EPIPE:
                        # the server closed the connection before the entire
                        # request was sent. this is probably because the
                        # server discarded the request on merits of lacking
                        # credentials.
                        # print "\r%s" % (27 * ' ')
                        return
                    raise
                sent = offset

                self.show_progress(offset, total_size)

            self.done(total_size)

    return HTTPConnectionWithProgress

def encode_multipart_formdata(params):
    """Return a tuple holding a content-type, including the boundary, and the
    values encoded for use as multipart form data.

    """
    boundary = '---BOUNDARY:%s---' % uuid.uuid4().bytes.encode('hex')
    buf = StringIO()

    for key, value in params.items():
        buf.write('--%s\n\n' % boundary)
        if isinstance(value, file) or isinstance(value, StringIO):
            filename = os.path.basename(value.name)
            buf.write('Content-Disposition: form-data; name="%s"; '
                      'filename="%s"\r\n' % (key, filename))
            buf.write("Content-Type: application/octet-stream\r\n")
            if isinstance(value, file):
                buf.write("\r\n%s\r\n" % value.read())
            else:
                buf.write("\r\n%s\r\n" % value.getvalue())
        else:
            buf.write('Content-Disposition: form-data; name="%s"' % key)
            buf.write('\r\n\r\n%s\r\n' % value)
        buf.write('--%s--\r\n\r\n' % boundary)

    content_type = 'multipart/form-data; boundary=%s' % boundary

    return content_type, buf.getvalue()

def request(url, method='GET', params=None, files=None, headers=None):
    o = urlparse.urlparse(url)

    params = params or {}
    files = files or {}
    headers = headers or {}

    params.update(o.params)

    if files:
        assert(method in ('POST', 'PUT'))
        params.update(files)
        ctype, body = encode_multipart_formdata(params)
        headers['Content-type'] = ctype
        headers['Content-length'] = str(len(body))
    else:
        body = urllib.urlencode(params)

    c = http_connection_cls(o.scheme == 'https', bool(files))(o.netloc)
    c.request(method, o.path, body, headers=headers)

    response = c.getresponse()
    response.data = response.read()

    c.close()

    return response

def api_request(url, method, params=None, files=None, headers=None,
                    task_id=None, accepted_callback=None):
    """Simple wrapper around `request()` that handles long-running jobs
    through task polling. `accepted_callback` is a function that is called
    with no arguments the first time a long-running process has been accepted.

    """
    headers = headers.copy() or {}

    if task_id is not None:
        # purge everything associated with multipart submissions to avoid
        # multiple uploads when polling a task by id.
        files = None
        for key in ('Content-type', 'Content-length'):
            if key in headers:
                del headers[key]

        headers.update({
            'X-Task-Id': task_id,
        })

    r = request(url, method, params, files, headers)

    if r.status == httplib.ACCEPTED:
        obj = json.loads(r.data)
        task_id = obj.get('task_id')

        if task_id is None:
            raise APIRequestError(url, "No task id present.")

        if accepted_callback is not None:
            accepted_callback()

            # remove the callback as it's only supposed to be called when the
            # task has been accepted.
            accepted_callback = None

        time.sleep(5.0)
        return api_request(url, method=method, params=params, files=files,
                           headers=headers, task_id=task_id)

    if r.status == httplib.OK:
        return json.loads(r.data)

    if r.status == httplib.FORBIDDEN:
        raise APIAuthenticationError()

    raise APIRequestError(url, "Server error.")


if __name__ == "__main__":
    dispatch()
